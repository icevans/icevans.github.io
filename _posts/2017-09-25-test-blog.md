---
title: Case and Class
layout: post
---

A comment in a Launch School discussion thread recently brought an interesting issue to my attention: case statements in Ruby behave a bit unexpectedly when `when` conditions are looking at classes. This is easiest to illustrate with an example:

```ruby
the_class = [].class

case the_class
when Array
  # do something
else
  # do something else
end
```

In this case, you'd expect the `when Array` condition to be triggered. In fact, however, the `when` condition evaluates to false and the `else` code gets triggered. Why is this?

First, notice that if we do:

```ruby
if the_class == Array
  # do something
else
  # do something else
end
```

then the first condition evaluates to true and the else code never gets executed. It will be helpful later to recall that `==` is really just a method, so we can rewrite the above as:

```ruby
if the_class.==(Array)
  #do something
else
  #do something else
end
```

Clearly, then, `case the_class` is not calling `.==` on `the_class` and passing the objects in the `when` conditions as parameters. A bit of Googling reveals that case statements in Ruby instead call the `#===` method.

At the highest level, `#===` is an instance method of the `Object` class. The documentation states that

"Case Equality – For class Object, effectively the same as calling #==, but typically overridden by descendants to provide meaningful semantics in case statements."

Since we've already established that our results are different from `#==`, the descendent must by overriding this. What is the descendent? Well, in this case, it's a class. Unfortunately, the `Class` documentation doesn't list `#===` as an instance method. However, the documentation for `Class`'s _parent_, `Module`, does list a `#===` instance method. The documentation states that:

"mod === obj → true or false
Case Equality—Returns true if obj is an instance of mod or an instance of one of mod’s descendants. Of limited use for modules, but can be used in case statements to classify objects by class."

Now we're getting somewhere: `===`, when called on a `Module` (or any of its descendants), checks whether the object on the right side is _an instance of_ the object on the left. So:

```ruby
Array.===([])    # => true
Array.===(Array) # => false
```

The first is true because `[]` is an instance of `Array`. The second is false because `Array` is not an instance of itself (presumably, for good Russellian reasons) -- it is an instance of `Class`. So:

```ruby
Class.===(Array) # => true
```

This last example also reveals an additional interesting twist: `#===` is not reflexive! After all, `Class` is not an instance of `Array`, so `Array.===(Class)` returns `false`. Since `case` statements use `===`, we need to know whether

```ruby
case a
when b
```

is calling `.===` on `a` with `b` as a parameter, or on `b` with `a` as a parameter (i.e. whether it's equivalent to `if a.===(b)` or `if b.===(a)`). I couldn't find any documentation on this, but a few tests in irb reveal it's the latter.

We're finally ready for the payoff. Our original code:

```ruby
the_class = [].class

case the_class
when Array
  # do something
else
  # do something else
end
```
is actually equivalent to:
```ruby
the_class = [].class

if Array.===(the_class)
  # do something
else
  # do something else
end
```
Since `the_class` is not an instance of `Array` (remember: `Array` is not an instance of `Array`, it is an instance of `Class`), the first condition does not evaluate to true . Mystery solved! 

So how should we use a case statement to check the class of an object? Well, `Array.===(the_class)` does not return the result we're interested in, but `Array.===([])` does. So there's no need to explicitly get the class of `[]` and then pass that to the case statement. Instead, we can simply do:

```ruby
my_array = []

case my_array
when Array
  # do something
else
  #do something else
end
```
and we get the desired results. The `when` statement calls `===` on the class `Array` with `my_array` as a parameter. Since `Array` is a descendent of `Module`, `Module`'s rules for `===` apply, meaning that behind the scenes ruby checks whether `my_array` is an instance of `Array`. It is, and so the code we want gets executed. 

Although it at first seems counterintuitive, this way of writing the case statement really is much more readable and direct. And it's little bits of language design like this that make ruby so pleasant to use.