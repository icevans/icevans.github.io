---
title: A Closer Look at the BCrypt Gem
layout: post
---

Storing user passwords in plain text is a huge application security vulnerability. The usual way to avoid this is to store _hashed_ versions of the passwords. A hashed version of a password -- which I'll sometimes just call a 'hash' -- is the result of passing the password into a one-way function that returns a string of characters. The hashing function is a function in the mathematical sense: give the same input, it always returns the same value (there is some nuance to how this works in practice because of something called _salting_, which we'll get to later). And it is [one-way](https://en.wikipedia.org/wiki/One-way_function) in the sense that given a hash, it is very hard or practically impossible to compute the original password.

These two features make hashes an ideal way of storing passwords. If our store of hashes is ever compromised, the malicious actor cannot easily convert these hashes to user passwords. However, when a user attempts to log into the site using their password, we can easily run it through our hashing function and check whether the result is the same as the hash stored in our system.

This is, in a nutshell, the core algorithm behind authenticating users against a store of hashed password:

1. Retrieve stored hashed password for authenticating user
2. Run password authenticating user entered through hashing function
3. Check whether the results of 1 and 2 are the same

## BCrypt

Many hash functions are available, but one of the best options is bcrypt. Handily, there is a nice RubyGem called BCrypt that makes it easy to add bcrypt hashing to your application. The readme on Github has a nice overview of how to get started. When you receive a password from a user attempting to authenticate, you first pull up the hashed password associated with the user and then do:

```ruby
BCrypt::Password.new(hashed) == entered_password
```

This is pretty easy, but it seems to violate our mental model of how we authenticate via hashing. Here it looks like we're passing the _hash_ through some kind of function and checking whether the result equals the entered password. And this makes it look like `BCrypt::Password.new` can convert a hashed password back to plain text -- violating the supposed one-way feature of a hashing function! What's going on?

To find out, let's keep our wits about us, and remember our Ruby fundamentals. Clearly, `BCrypt::Password.new(hashed)` is going to return an instance of the `Password` class defined in the `BCrypt` module. Our entered password, however, is a string. That means that for `BCrypt::Password.new(hashed) == entered_password` to return `true`, the `Password` class will have to implement a suitable `==` method (it also means that `entered_password == BCrypt::Password.new(hashed)` will return `false`).

This an important clue. Perhaps the `BCrypt::Password#==` converts its argument, the entered password, to a hash, and then compares _that_ with the current `Password` instance (which is a hash). If we check the [source code](https://github.com/codahale/bcrypt-ruby/blob/master/lib/bcrypt/password.rb), we can surmise that this is precisely what's going.

```ruby
def ==(secret)
  super(BCrypt::Engine.hash_secret(secret, @salt))
end
```

`Password#==` uses the `BCrypt::Engine` class to convert the entered password to a hash, and then passes that to it parent class's `==` method. And, as it happens, the parent class of `BCrypt::Password` is our old friend `String`! So at the point we're just comparing two strings for equality.

So, to recap, when we call `==` a `BCrypt::Password` instance with a string argument, the `==` method will convert that string to a hash behind the scenes and then compare the result to the `BCrypt::Password` instance using `String#==`. And this, of course, conforms perfectly to our 3-step process above for authenticating users.


This is pretty slick, but it does raise a question: why not just pass the entered password directly to `BCrypt::Engine.hash_secret` and then compare that directly with the hash? Something like the following:

```ruby
hash == BCrypt::Engine.hash_secret(entered_password, salt)
```

The reason we can't do this is because of the `salt` parameter. And to understand this, we need to make a brief diversion and talk about _salting_.

## Salting

Password hashing is not immune to attack. If you obtain a list of usernames and hashes, one strategy is simply run a (_huge_) list of common passwords through the hashing function, checking each result to see if it matches something in the hashed password store -- if it does, yay, you just cracked someone's password. This brute force method may sound too slow, but the fact that modern computers are so fast and that most people use extremely common passwords (`password`, anyone?) make it surprisingly effective.

Bcrypt helps this by being an intentionally slow algorithm -- many orders of magnitude slower than other hashing algorithms like md5, or SHA1. Not only that, the algorithm includes a configurable `cost` parameter that can make the algorithm arbitrarily slow to compute, no matter how fast computers get in the future. Bcrypt is so slow that it just isn't practical (at least for any non-governmental entity that lacks the resources to throw astouding computational resources at the problem). 

However, there remains the possibility of using a [_Rainbow Table_](). The idea here is that malicious actors can generate in advance huge tables of common passwords run through bcrypt, that can be shared with others and constantly added to. Then, when a list of users and hashed passwords is attained, they can simply look up hashes in their database to find the original password (assuming their database has an entry for that hash).

Fortunately, it's not too difficult to make this strategy equally impractical. Rather than simply run the user's password through, we can generate a random, e.g., 21-character string for each user, add that to their password, and then run _that_ through the bcrypt algorithm. This is called _salting_ the password, and the number we add is a _salt_. Now, the hackers can no longer maintain a simple database associating passwords with hashes. Instead, they need a separate database for possible salt. If the salt is sufficiently long, this is impractical both in terms of storage space (who can afford to store tens of thousands of huge databases) and computational speed.

## Back to BCrypt

Happily, bcrypt has salting built-in. This is why the `BCrypt::Engine#hash_secret` method takes a `salt` parameter. And so, to return to the question, that led us into that digression about salting, if we wanted to check whether the entered password matches the hashed password for the user using:

```ruby
hash == BCrypt::Engine.hash_secret(entered_password, salt)
```

we'd need to get the same salt originally used to generate the stored hash. Now we can get this -- it's just the first 29 characters of the stored hash. But parsing the hash string like that every time we want to authenticate a user would be both annoying and error-prone. Instead, the BCrypt handles this for us.

And it does this by via its `Password` class. We store the hashes in our database as strings, so when we authenticate a user, we first need to convert the string back into a `BCrypt::Password` instance. When we instantiate a new `BCrypt::Password` object by passing in a hash string, `BCrypt` automatically parses the hash string and separates out the salt and stores it in an `@salt` instance variable (which is available via a public `#salt` attribute reader).

Next, when we call the `BCrypt::Password#==` instance method on our new `Password` instance, that method internally calls `BCrypt::Engine.hash_secret`, passing along the entered password _and_ the salt stored in `@salt`. This is really convenient -- you don't even need to think about salts to use BCrypt.

## Wrapping Up

So we've solved solved our mystery. Like any solution to hashing, BCrypt runs the candidate password through the same hashing function used to hash the user's original password (including the same salt), and then compares the result to the stored hash. Through some clever use of Ruby's expressive object model, we can write with a deceptively simple line of code:

```ruby
BCrypt::Password.new(stored_hash) == entered_password
```
